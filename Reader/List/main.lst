C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Object\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(2,SPEED) BROWSE INCDIR(hal\nrf24le1;hal\nrf24l01p;hal;co
                    -mpiler\c51;compiler\common) DEFINE(MCU_NRF24LE1) DEBUG OBJECTEXTEND PRINT(.\List\main.lst) TABS(2) OBJECT(.\Object\main.
                    -obj)

line level    source

   1          /****************************************Copyright (c)****************************************************
   2          **
   3          **                                 合肥艾克姆电子科技有限公司
   4          **                                  论坛：http://930ebbs.com
   5          **--------------File Info---------------------------------------------------------------------------------
   6          ** File name:     main.c
   7          ** Last modified Date: 2017-3-1
   8          ** Last Version:       1.3
   9          ** Descriptions:
  10          **
  11          **--------------------------------------------------------------------------------------------------------
  12          ** Created by:      FiYu
  13          ** Created date:    2014-11-12
  14          ** Version:         1.1
  15          ** Descriptions:    READER实验程序
  16          **
  17          **                      RF配置
  18          **                      模式：接收设备
  19          **                      信道：50
  20          **                      通道：PIPE0
  21          **                      速率：250kbps
  22          **                      功率：0dbm
  23          **                      CRC： 16位
  24          **                      地址：5字节，TX_ADDRESS
  25          **                      自动应答：关闭
  26          ** 串口波特率：57600
  27          **
  28          **
  29          **--------------------------------------------------------------------------------------------------------
  30          ** Modified by:
  31          ** Modified date:
  32          ** Version:
  33          ** Descriptions:
  34          **
  35          ** Rechecked by:
  36          **********************************************************************************************************
             -/
  37          #include <reg24le1.h>
  38          #include <stdint.h>
  39          #include "hal_nrf.h"
  40          #include "hal_nrf_hw.h"
  41          #include "hal_uart.h"
  42          #include "hal_clk.h"
  43          #include "hal_delay.h"
  44          #include "config.h"
  45          #include "hal_wdog.h"
  46          
  47          
  48          /*******************************************************************************************************
  49           * 变量定义
  50           *******************************************************************************************************/
  51          xdata uint8_t RxPayload[32];
  52          xdata uint8_t AckPayLoad[32];
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 2   

  53          uint8_t  RF_Recv_Flag;
  54          uint16_t PipeAndLen;
  55          xdata uint8_t  RX_ADDRESS[5]  = {0xE7, 0xE7, 0xE7, 0xE7, 0xE7}; // RX address
  56          
  57          xdata ReaderInformation ReaderInfo;
  58          
  59          xdata bool  RepFlag = false;
  60          xdata uint8_t dest_addr;
  61          //xdata uint8_t UARTSendbuf[MAX_REP_IDNUM * 5 + 10];
  62          //xdata uint8_t ID_Buf[MAX_TAG_BUFNUM][5];
  63          //xdata uint8_t ID_BufTmp[6];// CMD IDH IDL VH VL
  64          
  65          xdata uint8_t UARTSendbuf[MAX_REP_IDNUM * 11 + 10];
  66          xdata uint8_t ID_Buf[MAX_TAG_BUFNUM][11];
  67          xdata uint8_t ID_BufTmp[12];// CMD IDH IDL VH VL
  68          
  69          /******** ID_Buf数据格式  ******************
  70          字节    1      2     3    4   5   6       7       8       9       10      11    12
  71                计时器  IDH   IDL  VH  VL tempH   tempL   tempD   humyH   humyL   humyD
  72          *******************************************/
  73          xdata uint8_t TimeCount = 0;
  74          xdata uint8_t SecondFlag = 0;
  75          xdata uint8_t UartSN = 0;
  76          /*******************************************************************************************************
  77           * Function DEFINITIONS
  78           *******************************************************************************************************/
  79          void DataInBuffer(uint8_t dat);
  80          uint8_t Calculate_Fcs(uint8_t *buf);
  81          
  82          
  83          
  84          /*******************************************************************************************************
  85           * 描  述 : 初始化IO
  86           * 入  参 : 无
  87           * 返回值 : 无
  88           *******************************************************************************************************/
  89          void IoInit(void)
  90          {
  91   1          P0DIR = 0xF6;
  92   1          P1DIR = 0xFF;
  93   1      }
  94          /*******************************************************************************************************
  95           * 描  述 : Timer0初始化
  96           * 入  参 : 无
  97           * 返回值 : 无
  98           *******************************************************************************************************/
  99          void Timer0Init(void)
 100          {
 101   1          TMOD = 0x01;                       //16位定时器
 102   1          TH0  = (65536 - TIMER0_VALUE) / 256;   //写入初值
 103   1          TL0  = (65536 - TIMER0_VALUE) % 256;
 104   1          ET0  = 1;    //使能Timer0溢出中断
 105   1          TR0  = 1;    //启动Timer0
 106   1      }
 107          
 108          /*******************************************************************************************************
 109           * 描  述 : 初始化时钟
 110           * 入  参 : 无
 111           * 返回值 : 无
 112           *******************************************************************************************************/
 113          void ClockInit(void)
 114          {
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 3   

 115   1          hal_clk_set_16m_source(HAL_CLK_XOSC16M);   //使用外部16MHz晶振
 116   1      }
 117          
 118          /*******************************************************************************************************
 119           * 描  述 : 配置无线参数
 120           * 入  参 : 无
 121           * 返回值 : 无
 122           *******************************************************************************************************/
 123          void RfCofig(void)
 124          {
 125   1          RFCKEN = 1;      //使能RF时钟
 126   1      
 127   1      
 128   1          hal_nrf_close_pipe(HAL_NRF_ALL);          //先关闭所有的通道
 129   1          hal_nrf_open_pipe(HAL_NRF_PIPE0, false);   //再打开通道0.
 130   1      
 131   1          hal_nrf_set_operation_mode(HAL_NRF_PRX);  // 模式：接收机
 132   1          hal_nrf_set_rf_channel(READER_CH);        // RF信道：50。接收和发送必须处于同一信道
 133   1          hal_nrf_set_datarate(HAL_NRF_250KBPS);    // RF速率：250KBPS
 134   1          hal_nrf_set_output_power(HAL_NRF_0DBM);   // 功率：0DBM
 135   1          hal_nrf_set_crc_mode(HAL_NRF_CRC_16BIT);       //设置CRC校验：16位CRC。必须和发送设备一致。
 136   1          hal_nrf_set_address(HAL_NRF_PIPE0, RX_ADDRESS); //设置接收机地址
 137   1          hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, RX_PAYLOAD_LEN); // 接收模式下需要设置数据长度
 138   1          hal_nrf_set_power_mode(HAL_NRF_PWR_UP);     //接收机上电
 139   1      
 140   1          RF = 1;       //使能无线中断
 141   1          EA = 1;      // 使能全局中断
 142   1      
 143   1          CE_HIGH(); // 使能接收
 144   1      }
 145          /*******************************************************************************************************
 146           * 描  述 : 标签ID入缓存
 147           * 入  参 : 无
 148           * 返回值 : 无
 149           *******************************************************************************************************/
 150          void ID_Inbuf(void)
 151          {
 152   1          uint8_t i, idx;
 153   1          xdata uint8_t iswrite, lastcnt = 0, row = 0;
 154   1      
 155   1          idx = 0xFF;
 156   1      
 157   1          if(ID_BufTmp[0] == CMD_TAG_REPID)
 158   1          {
 159   2              iswrite = true;
 160   2      
 161   2              for(i = 0; i < MAX_TAG_BUFNUM; i++)
 162   2              {
 163   3                  if(ID_Buf[i][0] != 0)
 164   3                  {
 165   4                      if((ID_Buf[i][1] == ID_BufTmp[1]) && (ID_Buf[i][2] == ID_BufTmp[2]))//标签ID存在
 166   4                      {
 167   5                          if(ID_Buf[i][0] < ID_OVERTIME)  //未超过20秒收到相同的标签号不上报
 168   5                          {
 169   6                              iswrite = false;
 170   6                              break;
 171   6                          }
 172   5                          else
 173   5                          {
 174   6                              ID_Buf[i][0] = TAG_NEED_REP;
 175   6                              iswrite = false;
 176   6                              break;
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 4   

 177   6                          }
 178   5                      }
 179   4                      else
 180   4                      {
 181   5                          if(ID_Buf[i][0] > lastcnt)
 182   5                          {
 183   6                              lastcnt = ID_Buf[i][0];
 184   6                              row = i;
 185   6                          }
 186   5                      }
 187   4                  }
 188   3                  else
 189   3                  {
 190   4                      if(idx == 0xFF)idx = i;
 191   4                  }
 192   3              }
 193   2              if(iswrite == true) //ID需要写入缓存
 194   2              {
 195   3                  if(idx < MAX_TAG_BUFNUM)
 196   3                  {
 197   4                      for(i = 0; i < (RX_PAYLOAD_LEN - 2); i++)ID_Buf[idx][i + 1] = ID_BufTmp[i + 1];
 198   4                      ID_Buf[idx][0] = TAG_NEED_REP;
 199   4                  }
 200   3                  else
 201   3                  {
 202   4                      if(row < MAX_TAG_BUFNUM)
 203   4                      {
 204   5                          for(i = 0; i < (RX_PAYLOAD_LEN - 2); i++)ID_Buf[row][i + 1] = ID_BufTmp[i + 1];
 205   5                          ID_Buf[row][0] = TAG_NEED_REP;
 206   5                      }
 207   4                  }
 208   3              }
 209   2          }
 210   1      }
 211          
 212          /*******************************************************************************************************
 213           * 描  述 : 串口输出字符
 214           * 入  参 : 无
 215           * 返回值 : 无
 216           *******************************************************************************************************/
 217          void uart_sendchar(uint8_t dat)
 218          {
 219   1          S0BUF = dat;
 220   1          while(!TI0);
 221   1          TI0 = 0;
 222   1      }
 223          /*******************************************************************************************************
 224           * 描  述 : 串口输出字符串
 225           * 入  参 : 无
 226           * 返回值 : 无
 227           *******************************************************************************************************/
 228          void PutString(char *s)
 229          {
 230   1          while(*s != 0)
 231   1              uart_sendchar(*s++);
 232   1          //delay_ms(1);
 233   1      }
 234          /*******************************************************************************************************
 235           * 描  述 : UART上报数据打包
 236           * 入  参 : 无
 237           * 返回值 : 无
 238           *******************************************************************************************************/
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 5   

 239          void Uart_PackAndRepDat(void)
 240          {
 241   1          xdata uint8_t i, tagnum = 0, fcs;
 242   1        uint8_t temp[5],humy[5],id[5];
 243   1        
 244   1      //  memset(temp, 0, 5);
 245   1        //memset(humy, 0, 5);
 246   1        //memset(id, 0, 5);
 247   1        
 248   1          RepFlag = false;
 249   1      
 250   1          for(i = 0; i < MAX_TAG_BUFNUM; i++)
 251   1          {
 252   2              if(ID_Buf[i][0] > 1)
 253   2              {
 254   3                  ID_Buf[i][0]++;
 255   3                  if(ID_Buf[i][0] >= ID_OVERTIME)ID_Buf[i][0] = 0;
 256   3              }
 257   2          }
 258   1      
 259   1          UARTSendbuf[0] = FRAME_FIR_HEAD; //帧头
 260   1          UARTSendbuf[1] = FRAME_SEC_HEAD;
 261   1          UARTSendbuf[2] = DEST_ADDR;     // DA
 262   1          UARTSendbuf[3] = READER_ADDR;   // SA
 263   1      
 264   1          for(i = 0; i < MAX_TAG_BUFNUM; i++)
 265   1          {
 266   2              if(ID_Buf[i][0] == TAG_NEED_REP)
 267   2              {
 268   3                  /*UARTSendbuf[4 * tagnum + 8]  = ID_Buf[i][1];
 269   3                  UARTSendbuf[4 * tagnum + 9]  = ID_Buf[i][2];
 270   3                  UARTSendbuf[4 * tagnum + 10]  = ID_Buf[i][3];
 271   3                  UARTSendbuf[4 * tagnum + 11] = ID_Buf[i][4];
 272   3                  */
 273   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 8]  = ID_Buf[i][1];
 274   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 9]  = ID_Buf[i][2];
 275   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 10]  = ID_Buf[i][3];
 276   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 11] = ID_Buf[i][4];
 277   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 12]  = ID_Buf[i][5];
 278   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 13]  = ID_Buf[i][6];
 279   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 14]  = ID_Buf[i][7];
 280   3                  UARTSendbuf[PAYLOAD_LEN * tagnum + 15] = ID_Buf[i][8];
 281   3                  ID_Buf[i][0] = 2;
 282   3                  tagnum++;
 283   3                  RepFlag = true;
 284   3                  if(tagnum == MAX_REP_IDNUM)break;
 285   3              }
 286   2          }
 287   1          UartSN++;
 288   1          if(UartSN == 0xFF)UartSN = 1;
 289   1          //UARTSendbuf[4] = tagnum * 4 + 6;  // 长度
 290   1          UARTSendbuf[4] = tagnum * PAYLOAD_LEN + 6;  // 长度
 291   1          UARTSendbuf[5] = UartSN;          // 流水号
 292   1          UARTSendbuf[6] = REP_ID_INFO;     // 命令
 293   1          UARTSendbuf[7] = tagnum;          // TAG数量
 294   1      
 295   1          fcs = 0;
 296   1          for(i = 0; i < UARTSendbuf[4]; i++)fcs = fcs + UARTSendbuf[i + 2];
 297   1          UARTSendbuf[UARTSendbuf[4] + 2] = (256 - fcs) % 256;
 298   1          for(i = 0; i < (UARTSendbuf[4] + 3); i++)  hal_uart_putchar(UARTSendbuf[i] );
 299   1          
 300   1          //PutString(temp);    
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 6   

 301   1          //PutString(humy);
 302   1          //hal_uart_putchar('\r');
 303   1          //hal_uart_putchar('\n');
 304   1      }
*** WARNING C280 IN LINE 242 OF main.c: 'temp': unreferenced local variable
*** WARNING C280 IN LINE 242 OF main.c: 'humy': unreferenced local variable
*** WARNING C280 IN LINE 242 OF main.c: 'id': unreferenced local variable
 305          /*******************************************************************************************************
 306           * 描  述 : 主函数
 307           * 入  参 : 无
 308           * 返回值 : 无
 309           *******************************************************************************************************/
 310          void main()
 311          {
 312   1          uint8_t i;
 313   1      
 314   1          IoInit();
 315   1      
 316   1          ClockInit();
 317   1          RfCofig();
 318   1      
 319   1          hal_uart_init(UART_BAUD_57K6);  //初始化UART，波特率57600
 320   1      
 321   1          while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M) //等待时钟稳定
 322   1              ;
 323   1          Timer0Init();
 324   1      
 325   1          for(i = 0; i < MAX_TAG_BUFNUM; i++)ID_Buf[i][0] = 0;
 326   1      #ifdef  USE_WDT
                  hal_wdog_init(WDT_TIME);
              #endif
 329   1      
 330   1      
 331   1          while(1)
 332   1          {
 333   2      #ifdef  USE_WDT
                      hal_wdog_restart();
              #endif
 336   2      
 337   2              if(RF_Recv_Flag == true)//接收到Tag信息
 338   2              {
 339   3      #ifdef DEBUG_LED
 340   3                  D1 = ~D1;
 341   3      #endif
 342   3      
 343   3                  RF_Recv_Flag = false;//接收有效标志清零
 344   3                  ID_Inbuf();          //ID信息写入缓存
 345   3              }
 346   2      
 347   2              if(SecondFlag == true)//1秒定时时间到
 348   2              {
 349   3                  SecondFlag = false; //清零秒定时标志
 350   3                  Uart_PackAndRepDat();//串口上报数据
 351   3              }
 352   2          }
 353   1      }
 354          /*******************************************************************************************************
 355           * 描  述 : UART上报数据打包
 356           * 入  参 : 无
 357           * 返回值 : 无
 358           *******************************************************************************************************/
 359          void rf_irq() interrupt INTERRUPT_RFIRQ
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 7   

 360          {
 361   1          uint8_t irq_flags, i;
 362   1      
 363   1          irq_flags = hal_nrf_get_clear_irq_flags(); //读取并清除中断标志
 364   1      
 365   1          if(irq_flags & (1 << HAL_NRF_RX_DR)) //接收中断
 366   1          {
 367   2              while(!hal_nrf_rx_fifo_empty())
 368   2              {
 369   3                  PipeAndLen = hal_nrf_read_rx_payload(RxPayload);
 370   3      
 371   3                  if((PipeAndLen & 0xFF) == RX_PAYLOAD_LEN) //检查长度是否为12//6
 372   3                  {
 373   4                      if(((RxPayload[0] + RxPayload[1] + RxPayload[2] + RxPayload[3] + RxPayload[4] + RxPayload[
             -5]+
 374   4                        RxPayload[6] + RxPayload[7] + RxPayload[8] + RxPayload[9]
 375   4                        
 376   4                      ) % 256) == 0x00) //校验正确
 377   4                      {
 378   5                          for(i = 0; i < (RX_PAYLOAD_LEN - 1); i++)ID_BufTmp[i] = RxPayload[i];
 379   5                          RF_Recv_Flag = true;
 380   5                      }
 381   4                  }
 382   3                  hal_nrf_flush_rx();
 383   3              }
 384   2          }
 385   1          if(irq_flags & ((1 << HAL_NRF_TX_DS)))         // transimmter finish
 386   1          {
 387   2              hal_nrf_flush_tx();
 388   2          }
 389   1      
 390   1          if(irq_flags & ((1 << HAL_NRF_MAX_RT)))        // re-transimmter
 391   1          {
 392   2              hal_nrf_flush_tx();
 393   2          }
 394   1      }
 395          /*******************************************************************************************************
 396           * 描  述 : 计算累加和校核
 397           * 入  参 : 待校验的数组地址
 398           * 返回值 : 校验结果
 399           *******************************************************************************************************/
 400          uint8_t Calculate_Fcs(uint8_t *buf)
 401          {
 402   1          xdata uint8_t i, fcs;
 403   1          fcs = 0;
 404   1          for(i = 0; i < 6; i++)fcs  = fcs + *(buf + i);
 405   1          return (256 - fcs);
 406   1      }
 407          /*******************************************************************************************************
 408           * 描  述 : Timer0中断服务函数
 409           * 入  参 : 无
 410           * 返回值 : 无
 411           *******************************************************************************************************/
 412          void Timer0_irq() interrupt INTERRUPT_T0
 413          {
 414   1      
 415   1          TH0 = (65536 - TIMER0_VALUE) / 256;
 416   1          TL0 = (65536 - TIMER0_VALUE) % 256;
 417   1          TimeCount++;
 418   1      
 419   1          if(TimeCount == 50) //1000ms
 420   1          {
C51 COMPILER V9.54   MAIN                                                                  08/09/2019 15:43:56 PAGE 8   

 421   2              TimeCount = 0;
 422   2              SecondFlag = true;
 423   2          }
 424   1      }
 425          /*********************************END FILE****************************************************************
             -/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1956    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    985       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
