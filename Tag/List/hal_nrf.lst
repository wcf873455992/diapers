C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE HAL_NRF
OBJECT MODULE PLACED IN .\Object\hal_nrf.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE hal\nrf24l01p\hal_nrf.c COMPACT OPTIMIZE(4,SPEED) BROWSE INCDIR(hal\nrf2
                    -4le1;hal\nrf24l01p;hal;compiler\c51;compiler\common) DEFINE(MCU_NRF24LE1) DEBUG OBJECTEXTEND PRINT(.\List\hal_nrf.lst) T
                    -ABS(2) OBJECT(.\Object\hal_nrf.obj)

line level    source

   1          /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2           *
   3           * The information contained herein is confidential property of Nordic
   4           * Semiconductor ASA.Terms and conditions of usage are described in detail
   5           * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
   6           *
   7           * Licensees are granted free, non-transferable use of the information. NO
   8           * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9           * the file.
  10           *
  11           * $LastChangedRevision: 2713 $
  12           */
  13          
  14          /** @file
  15           * @brief Implementation of hal_nrf
  16          */
  17          /*lint -t2 */
  18          /*lint -esym( 534, hal_nrf_write_reg ) */
  19          /*lint -esym( 534, hal_nrf_rw ) */
  20          /*lint -e708 */
  21          /*lint -e46 */
  22          
  23          #include <stdint.h>
  24          #include <stdbool.h>
  25          
  26          #include "nordic_common.h"
  27          #include "hal_nrf.h"
  28          
  29          #define SET_BIT(pos) ((uint8_t) (1U<<( (uint8_t) (pos) )))
  30          #define UINT8(t) ((uint8_t) (t))
  31          
  32          /** Basis function read_reg.
  33           * Use this function to read the contents
  34           * of one radios register.
  35           *
  36           * @param reg Register to read
  37           * @return Register contents
  38          */
  39          uint8_t hal_nrf_read_reg(uint8_t reg);
  40          
  41          /** Basis function write_reg.
  42           * Use this function to write a new value to
  43           * a radio register.
  44           *
  45           * @param reg Register to write
  46           * @param value New value to write
  47           * @return Status register
  48          */
  49          uint8_t hal_nrf_write_reg(uint8_t reg, uint8_t value);
  50          
  51          /** Basis function, read_multibyte register .
  52           * Use this function to read multiple bytes from
  53           * a multibyte radio-register
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 2   

  54           *
  55           * @param reg Multibyte register to read from
  56           * @param *pbuf Pointer to buffer in which to store read bytes to
  57           *
  58           * @return pipe# of received data (MSB), if operation used by a hal_nrf_read_rx_pload
  59           * @return length of read data (LSB), either for hal_nrf_read_rx_pload or
  60           * for hal_nrf_get_address.
  61          */
  62          uint16_t hal_nrf_read_multibyte_reg(uint8_t reg, uint8_t *pbuf);
  63          
  64          /** Basis function, write_multibyte register.
  65           * Use this function to write multiple bytes to
  66           * a multiple radio register.
  67           *
  68           * @param reg Register to write
  69           * @param *pbuf pointer to buffer in which data to write is
  70           * @param length \# of bytes to write
  71          */
  72          void hal_nrf_write_multibyte_reg(uint8_t reg, const uint8_t *pbuf, uint8_t length);
  73          
  74          /**
  75           * Typedef for the CONFIG register. Contains all the bitaddressable
  76           * settings in the bits struct and the value sent to the radio in the uint8_t
  77           */
  78          typedef union
  79          {
  80              uint8_t value;
  81              struct
  82              {
  83                  uint8_t prim_rx : 1;
  84                  uint8_t pwr_up : 1;
  85                  uint8_t crc0 : 1;
  86                  uint8_t en_crc : 1;
  87                  uint8_t mask_max_rt : 1;
  88                  uint8_t mask_tx_ds : 1;
  89                  uint8_t mask_rx_dr : 1;
  90                  const uint8_t : 1;
  91                  } bits;
  92              } config_t;
  93          
  94              /**
  95               * Typedef for the EN_AA, EN_RXADDR and DYNPD registers. Contains all the
  96               * bitaddressable settings in the bits struct and the value sent to the radio
  97               * in the uint8_t
  98               */
  99              typedef union
 100                  {
 101                      uint8_t value;
 102                      struct
 103                      {
 104                          uint8_t pipe_0 : 1;
 105                          uint8_t pipe_1 : 1;
 106                          uint8_t pipe_2 : 1;
 107                          uint8_t pipe_3 : 1;
 108                          uint8_t pipe_4 : 1;
 109                          uint8_t pipe_5 : 1;
 110                          const uint8_t : 2;
 111                      } bits;
 112                  } en_pipes_t;
 113          
 114              /**
 115               * Typedef for the SETUP_AW register. Contains all the bitaddressable
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 3   

 116               * settings in the bits struct and the value sent to the radio in the uint8_t
 117               */
 118              typedef union
 119                  {
 120                      uint8_t value;
 121                      struct
 122                      {
 123                          uint8_t aw : 2;
 124                          const uint8_t : 6;
 125                      } bits;
 126                  } setup_aw_t;
 127          
 128              /**
 129               * Typedef for the SETUP_RETR register. Contains all the bitaddressable
 130               * settings in the bits struct and the value sent to the radio in the uint8_t
 131               */
 132              typedef union
 133                  {
 134                      uint8_t value;
 135                      struct
 136                      {
 137                          uint8_t arc : 4;
 138                          uint8_t ard : 4;
 139                      } bits;
 140                  } setup_retr_t;
 141          
 142              /**
 143               * Typedef for the RF_CH register. Contains all the bitaddressable
 144               * settings in the bits struct and the value sent to the radio in the uint8_t
 145               */
 146              typedef union
 147                  {
 148                      uint8_t value;
 149                      struct
 150                      {
 151                          uint8_t rf_ch : 7;
 152                          const uint8_t : 1;
 153                      } bits;
 154                  } rf_ch_t;
 155          
 156              /**
 157               * Typedef for the RF_SETUP register. Contains all the bitaddressable
 158               * settings in the bits struct and the value sent to the radio in the uint8_t
 159               */
 160              typedef union
 161                  {
 162                      uint8_t value;
 163                      struct
 164                      {
 165                          const uint8_t : 1;
 166                          uint8_t rf_pwr : 2;
 167                          uint8_t rf_dr_high : 1;
 168                          uint8_t pll_lock : 1;
 169                          uint8_t rf_dr_low : 1;
 170                          const uint8_t : 1;
 171                          uint8_t cont_wave : 1;
 172                      } bits;
 173                  } rf_setup_t;
 174          
 175              /**
 176               * Typedef for the RX_PW_Px registers. Contains all the bitaddressable
 177               * settings in the bits struct and the value sent to the radio in the uint8_t
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 4   

 178               */
 179              typedef union
 180                  {
 181                      uint8_t value;
 182                      struct
 183                      {
 184                          uint8_t rx_pw : 6;
 185                          const uint8_t : 2;
 186                      } bits;
 187                  } rx_pw_t;
 188          
 189              /**
 190               * Typedef for the FEATURE register. Contains all the bitaddressable
 191               * settings in the bits struct and the value sent to the radio in the uint8_t
 192               */
 193              typedef union
 194                  {
 195                      uint8_t value;
 196                      struct
 197                      {
 198                          uint8_t en_dyn_ack : 1;
 199                          uint8_t en_ack_pay : 1;
 200                          uint8_t en_dpl : 1;
 201                          const uint8_t : 5;
 202                      } bits;
 203                  } feature_t;
 204          
 205              void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode)
 206          {
 207   1          config_t config;
 208   1          config.value = hal_nrf_read_reg (CONFIG);
 209   1      
 210   1          if(op_mode == HAL_NRF_PRX)
 211   1          {
 212   2              config.bits.prim_rx = 1U;
 213   2          }
 214   1          else
 215   1          {
 216   2              config.bits.prim_rx = 0U;
 217   2          }
 218   1      
 219   1          hal_nrf_write_reg (CONFIG, config.value);
 220   1      }
 221          
 222          void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode)
 223          {
 224   1          config_t config;
 225   1          config.value = hal_nrf_read_reg (CONFIG);
 226   1      
 227   1          if(pwr_mode == HAL_NRF_PWR_UP)
 228   1          {
 229   2              config.bits.pwr_up = 1U;
 230   2          }
 231   1          else
 232   1          {
 233   2              config.bits.pwr_up = 0U;
 234   2          }
 235   1      
 236   1          hal_nrf_write_reg (CONFIG, config.value);
 237   1      }
 238          
 239          void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode)
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 5   

 240          {
 241   1          config_t config;
 242   1          config.value = hal_nrf_read_reg (CONFIG);
 243   1      
 244   1          switch (crc_mode)
 245   1          {
 246   2          case HAL_NRF_CRC_OFF:
 247   2              config.bits.en_crc = 0U;
 248   2              break;
 249   2          case HAL_NRF_CRC_8BIT:
 250   2              config.bits.en_crc = 1U;
 251   2              config.bits.crc0 = 0U;
 252   2              break;
 253   2          case HAL_NRF_CRC_16BIT:
 254   2              config.bits.en_crc = 1U;
 255   2              config.bits.crc0 = 1U;
 256   2              break;
 257   2          default:
 258   2              break;
 259   2          }
 260   1      
 261   1          hal_nrf_write_reg (CONFIG, config.value);
 262   1      }
 263          
 264          void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state)
 265          {
 266   1          config_t config;
 267   1          config.value = hal_nrf_read_reg (CONFIG);
 268   1      
 269   1          switch (int_source)
 270   1          {
 271   2          case HAL_NRF_MAX_RT:
 272   2              config.bits.mask_max_rt = irq_state ? 0U : 1U;
 273   2              break;
 274   2          case HAL_NRF_TX_DS:
 275   2              config.bits.mask_tx_ds = irq_state ? 0U : 1U;
 276   2              break;
 277   2          case HAL_NRF_RX_DR:
 278   2              config.bits.mask_rx_dr = irq_state ? 0U : 1U;
 279   2              break;
 280   2          }
 281   1      
 282   1          hal_nrf_write_reg (CONFIG, config.value);
 283   1      }
 284          
 285          uint8_t hal_nrf_get_clear_irq_flags(void)
 286          {
 287   1          uint8_t retval;
 288   1      
 289   1          retval = hal_nrf_write_reg (STATUS, (BIT_6 | BIT_5 | BIT_4));
 290   1      
 291   1          return (retval & (BIT_6 | BIT_5 | BIT_4));
 292   1      }
 293          
 294          uint8_t hal_nrf_clear_irq_flags_get_status(void)
 295          {
 296   1          uint8_t retval;
 297   1      
 298   1          // When RFIRQ is cleared (when calling write_reg), pipe information is unreliable (read again with rea
             -d_reg)
 299   1          retval = hal_nrf_write_reg (STATUS, (BIT_6 | BIT_5 | BIT_4)) & (BIT_6 | BIT_5 | BIT_4);
 300   1          retval |= hal_nrf_read_reg (STATUS) & (BIT_3 | BIT_2 | BIT_1 | BIT_0);
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 6   

 301   1      
 302   1          return (retval);
 303   1      }
 304          
 305          
 306          void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source)
 307          {
 308   1          hal_nrf_write_reg (STATUS, SET_BIT(int_source));
 309   1      }
 310          
 311          uint8_t hal_nrf_get_irq_flags(void)
 312          {
 313   1          return hal_nrf_nop() & (BIT_6 | BIT_5 | BIT_4);
 314   1      }
 315          
 316          void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack)
 317          {
 318   1          en_pipes_t en_rxaddr;
 319   1          en_pipes_t en_aa;
 320   1          en_rxaddr.value = hal_nrf_read_reg (EN_RXADDR);
 321   1          en_aa.value = hal_nrf_read_reg (EN_AA);
 322   1      
 323   1          switch(pipe_num)
 324   1          {
 325   2          case HAL_NRF_PIPE0:
 326   2          case HAL_NRF_PIPE1:
 327   2          case HAL_NRF_PIPE2:
 328   2          case HAL_NRF_PIPE3:
 329   2          case HAL_NRF_PIPE4:
 330   2          case HAL_NRF_PIPE5:
 331   2              en_rxaddr.value = en_rxaddr.value | SET_BIT(pipe_num);
 332   2      
 333   2              if(auto_ack)
 334   2              {
 335   3                  en_aa.value = en_aa.value | SET_BIT(pipe_num);
 336   3              }
 337   2              else
 338   2              {
 339   3                  en_aa.value = en_aa.value & (uint8_t)~SET_BIT(pipe_num);
 340   3              }
 341   2              break;
 342   2      
 343   2          case HAL_NRF_ALL:
 344   2              en_rxaddr.value = (uint8_t)(~(BIT_6 | BIT_7));
 345   2      
 346   2              if(auto_ack)
 347   2              {
 348   3                  en_aa.value = (uint8_t)(~(BIT_6 | BIT_7));
 349   3              }
 350   2              else
 351   2              {
 352   3                  en_aa.value = 0U;
 353   3              }
 354   2              break;
 355   2      
 356   2          case HAL_NRF_TX:
 357   2          default:
 358   2              break;
 359   2          }
 360   1      
 361   1          hal_nrf_write_reg (EN_RXADDR, en_rxaddr.value);
 362   1          hal_nrf_write_reg (EN_AA, en_aa.value);
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 7   

 363   1      }
 364          
 365          void hal_nrf_close_pipe(hal_nrf_address_t pipe_num)
 366          {
 367   1          en_pipes_t en_rxaddr;
 368   1          en_pipes_t en_aa;
 369   1          en_rxaddr.value = hal_nrf_read_reg (EN_RXADDR);
 370   1          en_aa.value = hal_nrf_read_reg (EN_AA);
 371   1      
 372   1          switch(pipe_num)
 373   1          {
 374   2          case HAL_NRF_PIPE0:
 375   2          case HAL_NRF_PIPE1:
 376   2          case HAL_NRF_PIPE2:
 377   2          case HAL_NRF_PIPE3:
 378   2          case HAL_NRF_PIPE4:
 379   2          case HAL_NRF_PIPE5:
 380   2              en_rxaddr.value = en_rxaddr.value & (uint8_t)~SET_BIT(pipe_num);
 381   2              en_aa.value = en_aa.value & (uint8_t)~SET_BIT(pipe_num);
 382   2              break;
 383   2      
 384   2          case HAL_NRF_ALL:
 385   2              en_rxaddr.value = 0U;
 386   2              en_aa.value = 0U;
 387   2              break;
 388   2      
 389   2          case HAL_NRF_TX:
 390   2          default:
 391   2              break;
 392   2          }
 393   1      
 394   1          hal_nrf_write_reg (EN_RXADDR, en_rxaddr.value);
 395   1          hal_nrf_write_reg (EN_AA, en_aa.value);
 396   1      }
 397          
 398          void hal_nrf_set_address(const hal_nrf_address_t address, const uint8_t *addr)
 399          {
 400   1          switch(address)
 401   1          {
 402   2          case HAL_NRF_TX:
 403   2          case HAL_NRF_PIPE0:
 404   2          case HAL_NRF_PIPE1:
 405   2              hal_nrf_write_multibyte_reg(W_REGISTER + RX_ADDR_P0 + (uint8_t) address, addr, hal_nrf_get_address
             -_width());
 406   2              break;
 407   2          case HAL_NRF_PIPE2:
 408   2          case HAL_NRF_PIPE3:
 409   2          case HAL_NRF_PIPE4:
 410   2          case HAL_NRF_PIPE5:
 411   2              hal_nrf_write_reg (RX_ADDR_P0 + (uint8_t) address, *addr);
 412   2              break;
 413   2      
 414   2          case HAL_NRF_ALL:
 415   2          default:
 416   2              break;
 417   2          }
 418   1      }
 419          
 420          uint8_t hal_nrf_get_address(uint8_t address, uint8_t *addr)
 421          {
 422   1          switch (address)
 423   1          {
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 8   

 424   2          case HAL_NRF_PIPE0:
 425   2          case HAL_NRF_PIPE1:
 426   2          case HAL_NRF_TX:
 427   2              return (uint8_t)hal_nrf_read_multibyte_reg (address, addr);
 428   2          default:
 429   2              *addr = hal_nrf_read_reg(RX_ADDR_P0 + address);
 430   2              return 1U;
 431   2          }
 432   1      }
 433          
 434          void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay)
 435          {
 436   1          setup_retr_t setup_retr;
 437   1          setup_retr.bits.ard = (uint8_t)(delay >> 8);
 438   1          setup_retr.bits.arc = retr;
 439   1      
 440   1          hal_nrf_write_reg (SETUP_RETR, setup_retr.value);
 441   1      }
 442          
 443          void hal_nrf_set_address_width(hal_nrf_address_width_t address_width)
 444          {
 445   1          setup_aw_t setup_aw;
 446   1          setup_aw.value = 0U;
 447   1          setup_aw.bits.aw = (uint8_t)address_width - 2U;
 448   1      
 449   1          hal_nrf_write_reg (SETUP_AW, setup_aw.value);
 450   1      }
 451          
 452          uint8_t hal_nrf_get_address_width (void)
 453          {
 454   1          return hal_nrf_read_reg (SETUP_AW) + 2U;
 455   1      }
 456          
 457          void hal_nrf_set_rx_payload_width(uint8_t pipe_num, uint8_t pload_width)
 458          {
 459   1          hal_nrf_write_reg (RX_PW_P0 + pipe_num, pload_width);
 460   1      }
 461          
 462          uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num)
 463          {
 464   1          en_pipes_t en_rxaddr;
 465   1          en_pipes_t en_aa;
 466   1          uint8_t en_rx_r, en_aa_r;
 467   1      
 468   1          en_rxaddr.value = hal_nrf_read_reg (EN_RXADDR);
 469   1          en_aa.value = hal_nrf_read_reg (EN_AA);
 470   1      
 471   1          switch (pipe_num)
 472   1          {
 473   2          case 0:
 474   2              en_rx_r = en_rxaddr.bits.pipe_0;
 475   2              en_aa_r = en_aa.bits.pipe_0;
 476   2              break;
 477   2          case 1:
 478   2              en_rx_r = en_rxaddr.bits.pipe_1;
 479   2              en_aa_r = en_aa.bits.pipe_1;
 480   2              break;
 481   2          case 2:
 482   2              en_rx_r = en_rxaddr.bits.pipe_2;
 483   2              en_aa_r = en_aa.bits.pipe_2;
 484   2              break;
 485   2          case 3:
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 9   

 486   2              en_rx_r = en_rxaddr.bits.pipe_3;
 487   2              en_aa_r = en_aa.bits.pipe_3;
 488   2              break;
 489   2          case 4:
 490   2              en_rx_r = en_rxaddr.bits.pipe_4;
 491   2              en_aa_r = en_aa.bits.pipe_4;
 492   2              break;
 493   2          case 5:
 494   2              en_rx_r = en_rxaddr.bits.pipe_5;
 495   2              en_aa_r = en_aa.bits.pipe_5;
 496   2              break;
 497   2          default:
 498   2              en_rx_r = 0U;
 499   2              en_aa_r = 0U;
 500   2              break;
 501   2          }
 502   1      
 503   1          return (uint8_t)(en_aa_r << 1) + en_rx_r;
 504   1      }
 505          
 506          uint8_t hal_nrf_get_auto_retr_status(void)
 507          {
 508   1          return hal_nrf_read_reg(OBSERVE_TX);
 509   1      }
 510          
 511          uint8_t hal_nrf_get_packet_lost_ctr(void)
 512          {
 513   1          return ((hal_nrf_read_reg(OBSERVE_TX) & (BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4);
 514   1      }
 515          
 516          uint8_t hal_nrf_get_rx_payload_width(uint8_t pipe_num)
 517          {
 518   1          uint8_t pw;
 519   1      
 520   1          switch (pipe_num)
 521   1          {
 522   2          case 0:
 523   2              pw = hal_nrf_read_reg (RX_PW_P0);
 524   2              break;
 525   2          case 1:
 526   2              pw = hal_nrf_read_reg (RX_PW_P1);
 527   2              break;
 528   2          case 2:
 529   2              pw = hal_nrf_read_reg (RX_PW_P2);
 530   2              break;
 531   2          case 3:
 532   2              pw = hal_nrf_read_reg (RX_PW_P3);
 533   2              break;
 534   2          case 4:
 535   2              pw = hal_nrf_read_reg (RX_PW_P4);
 536   2              break;
 537   2          case 5:
 538   2              pw = hal_nrf_read_reg (RX_PW_P5);
 539   2              break;
 540   2          default:
 541   2              pw = 0U;
 542   2              break;
 543   2          }
 544   1      
 545   1          return pw;
 546   1      }
 547          
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 10  

 548          void hal_nrf_set_rf_channel(uint8_t channel)
 549          {
 550   1          rf_ch_t rf_ch;
 551   1          rf_ch.value = 0U;
 552   1          rf_ch.bits.rf_ch = channel;
 553   1          hal_nrf_write_reg (RF_CH, rf_ch.value);
 554   1      }
 555          
 556          void hal_nrf_set_output_power(hal_nrf_output_power_t power)
 557          {
 558   1          rf_setup_t rf_setup;
 559   1          rf_setup.value = hal_nrf_read_reg (RF_SETUP);
 560   1      
 561   1          rf_setup.bits.rf_pwr = (uint8_t)power;
 562   1      
 563   1          hal_nrf_write_reg (RF_SETUP, rf_setup.value);
 564   1      }
 565          
 566          void hal_nrf_set_datarate(hal_nrf_datarate_t datarate)
 567          {
 568   1          rf_setup_t rf_setup;
 569   1          rf_setup.value = hal_nrf_read_reg (RF_SETUP);
 570   1      
 571   1          switch (datarate)
 572   1          {
 573   2          case HAL_NRF_250KBPS:
 574   2              rf_setup.bits.rf_dr_low = 1U;
 575   2              rf_setup.bits.rf_dr_high = 0U;
 576   2              break;
 577   2          case HAL_NRF_1MBPS:
 578   2              rf_setup.bits.rf_dr_low = 0U;
 579   2              rf_setup.bits.rf_dr_high = 0U;
 580   2              break;
 581   2          case HAL_NRF_2MBPS:
 582   2          default:
 583   2              rf_setup.bits.rf_dr_low = 0U;
 584   2              rf_setup.bits.rf_dr_high = 1U;
 585   2              break;
 586   2          }
 587   1      
 588   1          hal_nrf_write_reg (RF_SETUP, rf_setup.value);
 589   1      }
 590          
 591          bool hal_nrf_rx_fifo_empty(void)
 592          {
 593   1          return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> RX_EMPTY) & 0x01U);
 594   1      }
 595          
 596          bool hal_nrf_rx_fifo_full(void)
 597          {
 598   1          return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> RX_FULL) & 0x01U);
 599   1      }
 600          
 601          bool hal_nrf_tx_fifo_empty(void)
 602          {
 603   1          return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> TX_EMPTY) & 0x01U);
 604   1      }
 605          
 606          bool hal_nrf_tx_fifo_full(void)
 607          {
 608   1          return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> TX_FIFO_FULL) & 0x01U);
 609   1      }
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 11  

 610          
 611          uint8_t hal_nrf_get_tx_fifo_status(void)
 612          {
 613   1          return ((hal_nrf_read_reg(FIFO_STATUS) & ((1U << TX_FIFO_FULL) | (1U << TX_EMPTY))) >> 4);
 614   1      }
 615          
 616          uint8_t hal_nrf_get_rx_fifo_status(void)
 617          {
 618   1          return (hal_nrf_read_reg(FIFO_STATUS) & ((1U << RX_FULL) | (1U << RX_EMPTY)));
 619   1      }
 620          
 621          uint8_t hal_nrf_get_fifo_status(void)
 622          {
 623   1          return hal_nrf_read_reg(FIFO_STATUS);
 624   1      }
 625          
 626          uint8_t hal_nrf_get_transmit_attempts(void)
 627          {
 628   1          return (hal_nrf_read_reg(OBSERVE_TX) & (BIT_3 | BIT_2 | BIT_1 | BIT_0));
 629   1      }
 630          
 631          bool hal_nrf_get_carrier_detect(void)
 632          {
 633   1          return (bool)(hal_nrf_read_reg(CD) & 0x01U);
 634   1      }
 635          
 636          void hal_nrf_activate_features(void)
 637          {
 638   1          return;
 639   1      }
 640          
 641          void hal_nrf_setup_dynamic_payload (uint8_t setup)
 642          {
 643   1          en_pipes_t dynpd;
 644   1          dynpd.value = setup & (uint8_t)~0xC0U;
 645   1      
 646   1          hal_nrf_write_reg (DYNPD, dynpd.value);
 647   1      }
 648          
 649          void hal_nrf_enable_dynamic_payload(bool enable)
 650          {
 651   1          feature_t feature;
 652   1          feature.value = hal_nrf_read_reg (FEATURE);
 653   1          feature.bits.en_dpl = (enable) ? 1U : 0U;
 654   1      
 655   1          hal_nrf_write_reg (FEATURE, feature.value);
 656   1      }
 657          
 658          void hal_nrf_enable_ack_payload(bool enable)
 659          {
 660   1          feature_t feature;
 661   1          feature.value = hal_nrf_read_reg (FEATURE);
 662   1          feature.bits.en_ack_pay = (enable) ? 1U : 0U;
 663   1      
 664   1          hal_nrf_write_reg (FEATURE, feature.value);
 665   1      }
 666          
 667          void hal_nrf_enable_dynamic_ack(bool enable)
 668          {
 669   1          feature_t feature;
 670   1          feature.value = hal_nrf_read_reg (FEATURE);
 671   1          feature.bits.en_dyn_ack = (enable) ? 1U : 0U;
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 12  

 672   1      
 673   1          hal_nrf_write_reg (FEATURE, feature.value);
 674   1      }
 675          
 676          void hal_nrf_write_tx_payload(const uint8_t *tx_pload, uint8_t length)
 677          {
 678   1          hal_nrf_write_multibyte_reg(W_TX_PAYLOAD, tx_pload, length);
 679   1      }
 680          
 681          void hal_nrf_write_tx_payload_noack(const uint8_t *tx_pload, uint8_t length)
 682          {
 683   1          hal_nrf_write_multibyte_reg(W_TX_PAYLOAD_NOACK, tx_pload, length);
 684   1      }
 685          
 686          void hal_nrf_write_ack_payload(uint8_t pipe, const uint8_t *tx_pload, uint8_t length)
 687          {
 688   1          hal_nrf_write_multibyte_reg(W_ACK_PAYLOAD | pipe, tx_pload, length);
 689   1      }
 690          
 691          uint8_t hal_nrf_read_rx_payload_width(void)
 692          {
 693   1          return hal_nrf_read_reg(R_RX_PL_WID);
 694   1      }
 695          
 696          uint16_t hal_nrf_read_rx_payload(uint8_t *rx_pload)
 697          {
 698   1          return hal_nrf_read_multibyte_reg(UINT8(HAL_NRF_RX_PLOAD), rx_pload);
 699   1      }
 700          
 701          uint8_t hal_nrf_get_rx_data_source(void)
 702          {
 703   1          return ((hal_nrf_nop() & (BIT_3 | BIT_2 | BIT_1)) >> 1);
 704   1      }
 705          
 706          void hal_nrf_reuse_tx(void)
 707          {
 708   1          CSN_LOW();
 709   1          hal_nrf_rw(REUSE_TX_PL);
 710   1          CSN_HIGH();
 711   1      }
 712          
 713          bool hal_nrf_get_reuse_tx_status(void)
 714          {
 715   1          return (bool)((hal_nrf_get_fifo_status() & (1U << TX_REUSE)) >> TX_REUSE);
 716   1      }
 717          
 718          void hal_nrf_flush_rx(void)
 719          {
 720   1          CSN_LOW();
 721   1          hal_nrf_rw(FLUSH_RX);
 722   1          CSN_HIGH();
 723   1      }
 724          
 725          void hal_nrf_flush_tx(void)
 726          {
 727   1          CSN_LOW();
 728   1          hal_nrf_rw(FLUSH_TX);
 729   1          CSN_HIGH();
 730   1      }
 731          
 732          uint8_t hal_nrf_nop(void)
 733          {
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 13  

 734   1          uint8_t retval;
 735   1      
 736   1          CSN_LOW();
 737   1          retval = hal_nrf_rw(NOP);
 738   1          CSN_HIGH();
 739   1      
 740   1          return retval;
 741   1      }
 742          
 743          void hal_nrf_set_pll_mode(bool pll_lock)
 744          {
 745   1          rf_setup_t rf_setup;
 746   1          rf_setup.value = hal_nrf_read_reg (RF_SETUP);
 747   1          rf_setup.bits.pll_lock = (pll_lock) ? 1U : 0U;
 748   1      
 749   1          hal_nrf_write_reg(RF_SETUP, rf_setup.value);
 750   1      }
 751          
 752          void hal_nrf_enable_continious_wave (bool enable)
 753          {
 754   1          rf_setup_t rf_setup;
 755   1          rf_setup.value = hal_nrf_read_reg (RF_SETUP);
 756   1          rf_setup.bits.cont_wave = (enable ? 1U : 0U);
 757   1      
 758   1          hal_nrf_write_reg(RF_SETUP, rf_setup.value);
 759   1      }
 760          
 761          uint8_t hal_nrf_read_reg(uint8_t reg)
 762          {
 763   1          uint8_t temp;
 764   1      
 765   1          CSN_LOW();
 766   1      
 767   1          HAL_NRF_HW_SPI_WRITE(reg);
 768   1          while(HAL_NRF_HW_SPI_BUSY) {}
 769   1          temp = HAL_NRF_HW_SPI_READ();
 770   1      
 771   1          HAL_NRF_HW_SPI_WRITE(0U);
 772   1          while(HAL_NRF_HW_SPI_BUSY) {}
 773   1          temp = HAL_NRF_HW_SPI_READ();
 774   1      
 775   1          CSN_HIGH();
 776   1      
 777   1          return temp;
 778   1      }
 779          
 780          uint8_t hal_nrf_write_reg(uint8_t reg, uint8_t value)
 781          {
 782   1          uint8_t retval;
 783   1          /*lint -esym(550,dummy) symbol not accessed*/
 784   1          /*lint -esym(438,dummy) last assigned value not used*/
 785   1          /*lint -esym(838,dummy) previously assigned value not used*/
 786   1          uint8_t volatile dummy;
 787   1      
 788   1          CSN_LOW();
 789   1      
 790   1          HAL_NRF_HW_SPI_WRITE((W_REGISTER + reg));
 791   1          while(HAL_NRF_HW_SPI_BUSY) {}
 792   1          retval = HAL_NRF_HW_SPI_READ();
 793   1      
 794   1          HAL_NRF_HW_SPI_WRITE(value);
 795   1          while(HAL_NRF_HW_SPI_BUSY) {}
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 14  

 796   1          dummy = HAL_NRF_HW_SPI_READ();
 797   1      
 798   1          CSN_HIGH();
 799   1      
 800   1          return retval;
 801   1      }
 802          
 803          #define NRF_READ_MULTIBYTE_REG_COMMON_BODY \
 804              do \
 805              { \
 806                HAL_NRF_HW_SPI_WRITE(0U); \
 807                if (!first_round) \
 808                { \
 809                  *buf = read_byte; \
 810                  buf++; \
 811                } \
 812                else \
 813                { \
 814                  first_round = false; \
 815                } \
 816                /* wait for byte transfer finished */ \
 817                while(HAL_NRF_HW_SPI_BUSY){} \
 818                read_byte = HAL_NRF_HW_SPI_READ(); \
 819              } while (--ctr); \
 820              *buf = read_byte;
 821          
 822          uint16_t hal_nrf_read_multibyte_reg(uint8_t reg, uint8_t *pbuf)
 823          {
 824   1          uint8_t ctr, length;
 825   1          uint8_t memtype;
 826   1          uint8_t read_byte; /*lint -esym(530,read_byte) symbol not initialized*/
 827   1          bool first_round;
 828   1          first_round = true;
 829   1      
 830   1          memtype = *(uint8_t *)(&pbuf);
 831   1      
 832   1          switch(reg)
 833   1          {
 834   2          case HAL_NRF_PIPE0:
 835   2          case HAL_NRF_PIPE1:
 836   2          case HAL_NRF_TX:
 837   2              length = ctr = hal_nrf_get_address_width();
 838   2              CSN_LOW();
 839   2              hal_nrf_rw(RX_ADDR_P0 + reg);
 840   2              break;
 841   2      
 842   2          case HAL_NRF_RX_PLOAD:
 843   2              reg = hal_nrf_get_rx_data_source();
 844   2              if (reg < 7U)
 845   2              {
 846   3                  length = ctr = hal_nrf_read_rx_payload_width();
 847   3                  CSN_LOW();
 848   3                  hal_nrf_rw(R_RX_PAYLOAD);
 849   3              }
 850   2              else
 851   2              {
 852   3                  ctr = length = 0U;
 853   3              }
 854   2              break;
 855   2      
 856   2          default:
 857   2              ctr = length = 0U;
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 15  

 858   2              break;
 859   2          }
 860   1      
 861   1          if (memtype == 0x00U)
 862   1          {
 863   2              uint8_t data *buf = (uint8_t data *)pbuf;
 864   2              NRF_READ_MULTIBYTE_REG_COMMON_BODY
 865   2          }
 866   1          else if (memtype == 0x01U)
 867   1          {
 868   2              uint8_t xdata *buf = (uint8_t xdata *)pbuf;
 869   2              NRF_READ_MULTIBYTE_REG_COMMON_BODY
 870   2          }
 871   1          else if (memtype == 0xFEU)
 872   1          {
 873   2              uint8_t pdata *buf = (uint8_t pdata *)pbuf;
 874   2              NRF_READ_MULTIBYTE_REG_COMMON_BODY
 875   2          }
 876   1          else
 877   1          {
 878   2              uint8_t *buf = (uint8_t *)pbuf;
 879   2              NRF_READ_MULTIBYTE_REG_COMMON_BODY
 880   2          }
 881   1      
 882   1          CSN_HIGH();
 883   1      
 884   1          return (((uint16_t) reg << 8) | length);
 885   1      }
 886          
 887          #define NRF_WRITE_MULTIBYTE_REG_COMMON_BODY \
 888            do \
 889            { \
 890              next = *buf; \
 891              buf++; \
 892              while(HAL_NRF_HW_SPI_BUSY) {}  /* wait for byte transfer finished */ \
 893              dummy = HAL_NRF_HW_SPI_READ(); \
 894              HAL_NRF_HW_SPI_WRITE(next); \
 895            } while (--length);
 896          /*lint -esym(550,dummy) symbol not accessed*/ \
 897          /*lint -esym(438,dummy) last assigned value not used*/ \
 898          /*lint -esym(838,dummy) previously assigned value not used*/ \
 899          void hal_nrf_write_multibyte_reg(uint8_t reg, const uint8_t *pbuf, uint8_t length)
 900          {
 901   1          uint8_t memtype;
 902   1          uint8_t next;
 903   1          uint8_t volatile dummy;
 904   1      
 905   1          memtype = *(uint8_t *)(&pbuf);
 906   1      
 907   1          CSN_LOW();
 908   1          HAL_NRF_HW_SPI_WRITE(reg);
 909   1      
 910   1          if (memtype == 0x00U)
 911   1          {
 912   2              const uint8_t data *buf = (const uint8_t data *)pbuf;
 913   2              NRF_WRITE_MULTIBYTE_REG_COMMON_BODY
 914   2          }
 915   1          else if (memtype == 0x01U)
 916   1          {
 917   2              const uint8_t xdata *buf = (const uint8_t xdata *)pbuf;
 918   2              NRF_WRITE_MULTIBYTE_REG_COMMON_BODY
 919   2          }
C51 COMPILER V9.54   HAL_NRF                                                               08/09/2019 16:39:58 PAGE 16  

 920   1          else if (memtype == 0xFEU)
 921   1          {
 922   2              const uint8_t pdata *buf = (const uint8_t pdata *)pbuf;
 923   2              NRF_WRITE_MULTIBYTE_REG_COMMON_BODY
 924   2          }
 925   1          else
 926   1          {
 927   2              const uint8_t *buf = (const uint8_t *)pbuf;
 928   2              NRF_WRITE_MULTIBYTE_REG_COMMON_BODY
 929   2          }
 930   1      
 931   1          while(HAL_NRF_HW_SPI_BUSY) {} /* wait for byte transfer finished */
 932   1          dummy = HAL_NRF_HW_SPI_READ();
 933   1          CSN_HIGH();
 934   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2523    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      76
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
