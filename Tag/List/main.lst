C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Object\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(4,SPEED) BROWSE INCDIR(hal\nrf24le1;hal\nrf24l01
                    -p;hal;compiler\c51;compiler\common) DEFINE(MCU_NRF24LE1) DEBUG OBJECTEXTEND PRINT(.\List\main.lst) TABS(2) OBJECT(.\Obje
                    -ct\main.obj)

line level    source

   1          /****************************************Copyright (c)****************************************************
   2          **
   3          **                                 ºÏ·Ê°¬¿ËÄ·µç×Ó¿Æ¼¼ÓÐÏÞ¹«Ë¾
   4          **                                  ÂÛÌ³£ºhttp://930ebbs.com
   5          **--------------File Info---------------------------------------------------------------------------------
   6          ** File name:     main.c
   7          ** Last modified Date: 2017-3-1
   8          ** Last Version:       1.3
   9          ** Descriptions:
  10          **
  11          **--------------------------------------------------------------------------------------------------------
  12          ** Created by:      FiYu
  13          ** Created date:    2014-11-12
  14          ** Version:         1.0
  15          ** Descriptions:    ÓÐÔ´RFIDÊµÑé³ÌÐò-TAG
  16          **                  ·¢ËÍÊý¾Ý¸ñÊ½
  17          **                  ³¤¶È£º6¸ö×Ö½Ú
  18          **                  ID³¤¶È£º2×Ö½Ú
  19          ×Ö½Ú:    1     2   3    4  5   6  7   8   9   10
  20          ÒâÒå:   ÃüÁî  IDH IDL  VH  VL  ÎÂ¶È   Êª¶È    Ð£Ñé
  21          
  22          **--------------------------------------------------------------------------------------------------------
  23          ** Modified by:
  24          ** Modified date:
  25          ** Version:
  26          ** Descriptions:
  27          **
  28          ** Rechecked by:
  29          **********************************************************************************************************
             -/
  30          #include <reg24le1.h>
  31          #include <stdint.h>
  32          #include <stdbool.h>
  33          #include "config.h"
  34          #include "hal_nrf.h"
  35          #include "hal_nrf_hw.h"
  36          #include "hal_clk.h"
  37          #include "hal_rtc.h"
  38          #include "hal_delay.h"
  39          #include "hal_adc.h"
  40          #include "hal_wdog.h"
  41          #include "hal_uart.h"
  42          
  43          #include <stdio.h>
  44          #include <string.h>
  45          
  46          #include "user/AHT10.h"
  47          #include "user/DHT11.h"
  48          #include "user/led.h"
  49          #include "user/key.h"
  50          
  51          /*-------------------¹Ü½Å¶¨Òå--------------------------------------------------*/
  52          #define  D1    P00  // ¿ª·¢°åÉÏµÄÖ¸Ê¾µÆD1
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 2   

  53          #define  D2    P01  // ¿ª·¢°åÉÏµÄÖ¸Ê¾µÆD2
  54          #define  S2    P12  // ¿ª·¢°åÉÏµÄ°´¼üS2
  55          #define  S3    P13  // ¿ª·¢°åÉÏµÄ°´¼üS3
  56          #define  ADC   P06
  57          
  58          
  59          
  60          /*******************************************************************************************************
  61           * ±äÁ¿¶¨Òå
  62           *******************************************************************************************************/
  63          xdata bool  radio_busy;
  64          xdata uint8_t  TxPayload[32];
  65          xdata uint8_t  RxPayload[32];
  66          uint16_t PipeAndLen;
  67          uint8_t  TX_ADDRESS[5]  = {0xE7, 0xE7, 0xE7, 0xE7, 0xE7}; // TX address
  68          
  69          xdata TagInformation TagInfo;
  70          
  71          
  72          /*******************************************************************************************************
  73           * Ãè  Êö : ³õÊ¼»¯IO
  74           * Èë  ²Î : ÎÞ
  75           * ·µ»ØÖµ : ÎÞ
  76           *******************************************************************************************************/
  77          void IoInit(void) {
  78   1          P0DIR = 0x00;
  79   1          P1DIR = 0x00;
  80   1      }
  81          #ifdef DEBUG_UART
              /*******************************************************************************************************
               * Ãè  Êö : ´®¿ÚÊä³ö×Ö·û
               * Èë  ²Î : ÎÞ
               * ·µ»ØÖµ : ÎÞ
               *******************************************************************************************************/
              void uart_sendchar(uint8_t dat) {
                  S0BUF = dat;
                  while(!TI0);
                  TI0 = 0;
              }
              #endif
  93          /*******************************************************************************************************
  94           * Ãè  Êö : ´®¿ÚÊä³ö×Ö·û´®
  95           * Èë  ²Î : ÎÞ
  96           * ·µ»ØÖµ : ÎÞ
  97           *******************************************************************************************************/
  98          void PutString(char *s) {
  99   1      #ifdef DEBUG_UART
                  while(*s != 0)
                      uart_sendchar(*s++);
                  //delay_ms(1);
              #endif
 104   1      }
*** WARNING C280 IN LINE 98 OF main.c: 's': unreferenced local variable
 105          /*********************************************************************************************************
 106          ** Ãè  Êö:  adc³õÊ¼»¯
 107          ** Èë  ²Î:  NONE
 108          ** ·µ»ØÖµ:  NONE
 109          *********************************************************************************************************/
 110          void adc_init(void) {
 111   1          hal_adc_set_input_channel(HAL_INP_VDD1_3);          //ÉèÖÃÍ¨µÀ ¼ì²â1/3 VDDµçÑ¹
 112   1          hal_adc_set_reference(HAL_ADC_REF_INT);             //ÉèÖÃ²Î¿¼µçÑ¹ ÄÚ²¿1.22V
 113   1          hal_adc_set_input_mode(HAL_ADC_SINGLE);             //µ¥¶ËÊäÈë
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 3   

 114   1          hal_adc_set_conversion_mode(HAL_ADC_SINGLE_STEP);   //µ¥´Î²ÉÑùÄ£Ê½
 115   1          hal_adc_set_sampling_rate(HAL_ADC_2KSPS);           //²ÉÑùËÙÂÊÎª  2ksps
 116   1          hal_adc_set_resolution(HAL_ADC_RES_12BIT);          //12Î»ADC
 117   1          hal_adc_set_data_just(HAL_ADC_JUST_RIGHT);          //Êý¾ÝÓÒ¶ÔÆë
 118   1      }
 119          
 120          /*******************************************************************************************************
 121           * Ãè  Êö : ÉèÖÃÐÝÃßÊ±¼ä
 122           * Èë  ²Î : period:ÐÝÃßÊ±¼ä
 123           * ·µ»ØÖµ : ÎÞ
 124           *******************************************************************************************************/
 125          void set_timer_period(uint16_t period) {
 126   1          if((period < 10) && (period > 65536))period = 32768;
 127   1      
 128   1          hal_rtc_start(false);
 129   1          hal_rtc_start(true);
 130   1          hal_rtc_set_compare_value(period - 1);
 131   1      }
 132          
 133          /*******************************************************************************************************
 134           * Ãè  Êö : ÅäÖÃÎÞÏß²ÎÊý
 135           * Èë  ²Î : ÎÞ
 136           * ·µ»ØÖµ : ÎÞ
 137           *******************************************************************************************************/
 138          void RfCofig(void) {
 139   1          RFCKEN = 1;      //Ê¹ÄÜRFÊ±ÖÓ
 140   1      
 141   1          hal_nrf_close_pipe(HAL_NRF_ALL);           //ÏÈ¹Ø±ÕËùÓÐµÄÍ¨µÀ.
 142   1          hal_nrf_open_pipe(HAL_NRF_PIPE0, false);    //ÔÙ´ò¿ªÍ¨µÀ0.
 143   1      
 144   1          hal_nrf_set_operation_mode(HAL_NRF_PTX);    // Ä£Ê½£º·¢ËÍ
 145   1          hal_nrf_set_rf_channel(TAG_CH);             // RFÐÅµÀ£º50¡£½ÓÊÕºÍ·¢ËÍ±ØÐë´¦ÓÚÍ¬Ò»ÐÅµÀ
 146   1          hal_nrf_set_datarate(HAL_NRF_250KBPS);      // RFËÙÂÊ£º250KBPS
 147   1          hal_nrf_set_output_power(HAL_NRF_0DBM);     // ¹¦ÂÊ£º0DBM
 148   1          hal_nrf_set_crc_mode(HAL_NRF_CRC_16BIT);    //ÉèÖÃCRCÐ£Ñé£º16Î»CRC¡£±ØÐëºÍ½ÓÊÕÉè±¸Ò»ÖÂ¡£
 149   1          hal_nrf_set_address(HAL_NRF_TX, TX_ADDRESS); //ÉèÖÃ·¢Éä»úµØÖ·
 150   1          hal_nrf_set_auto_retr(0, 1500);                //×Ô¶¯ÖØ·¢:0
 151   1      
 152   1          hal_nrf_set_power_mode(HAL_NRF_PWR_UP);         //·¢Éä»úÉÏµç
 153   1          RF = 1;       //Ê¹ÄÜÎÞÏßÖÐ¶Ï
 154   1          EA = 1;      // Ê¹ÄÜÈ«¾ÖÖÐ¶Ï
 155   1      }
 156          
 157          /*******************************************************************************************************
 158           * Ãè  Êö : Ê±ÖÓºÍRTC»½ÐÑÅäÖÃ
 159           * Èë  ²Î : ÎÞ
 160           * ·µ»ØÖµ : ÎÞ
 161           *******************************************************************************************************/
 162          void mcu_init(void) {
 163   1          hal_rtc_start(false);
 164   1          hal_clklf_set_source(HAL_CLKLF_RCOSC32K);           // Use 32.768KHzµÄÊ±ÖÓÔ´ÎªÄÚ²¿RC
 165   1      
 166   1          hal_rtc_set_compare_mode(HAL_RTC_COMPARE_MODE_0);   // Use 32 KHz timer mode 0
 167   1          set_timer_period(TAG_TIME);                         // Set the RTC2 time£¬card sleep time
 168   1          hal_clk_set_16m_source(HAL_CLK_XOSC16M);            // Always run on 16MHz crystal oscillator
 169   1          hal_clk_regret_xosc16m_on(0);                       // Keep XOSC16M off in register retention
 170   1      
 171   1          hal_rtc_start(true);
 172   1      
 173   1          while((CLKLFCTRL & 0x80) == 0x80);                  // Wait for the 32kHz to startup (change phase)
 174   1          while((CLKLFCTRL & 0x80) != 0x80);
 175   1      }
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 4   

 176          
 177          /*******************************************************************************************************
 178           * Ãè  Êö : ×é×°Êý¾Ý
 179           * Èë  ²Î : ÎÞ
 180           * ·µ»ØÖµ : ÎÞ
 181           *******************************************************************************************************/
 182          void Assemble_Data(void) {
 183   1          xdata uint8_t fcs = 0, i;
 184   1      
 185   1      
 186   1          TxPayload[0] = 0x1E;
 187   1          TxPayload[1] = TagInfo.id.id8[0];  //IDL
 188   1          TxPayload[2] = TagInfo.id.id8[1];  //IDH
 189   1          TxPayload[3] = TagInfo.CellVoltageH;
 190   1          TxPayload[4] = TagInfo.CellVoltageL;
 191   1          TxPayload[5] = TagInfo.tempH;
 192   1          TxPayload[6] = TagInfo.tempL;
 193   1          TxPayload[7] = TagInfo.humyH;
 194   1          TxPayload[8] = TagInfo.humyL;
 195   1      
 196   1          for(i = 0; i < (MAX_TX_PAYLOAD - 1); i++)fcs += TxPayload[i];
 197   1      
 198   1          TxPayload[MAX_TX_PAYLOAD - 1] = (256 - fcs) % 256;
 199   1      }
 200          void CellVoltage() {
 201   1          uint32_t  ad_value = 0, temp = 0;
 202   1          hal_adc_start();           //Æô¶¯ADC
 203   1          while( hal_adc_busy())     //µÈ´ýADC×ª»»½áÊø
 204   1              ;
 205   1          TagInfo.CellVoltageH = hal_adc_read_MSB(); //¶ÁÈ¡ADC²ÉÑùÖµ
 206   1          TagInfo.CellVoltageL = hal_adc_read_LSB();
 207   1          ad_value = (ad_value | hal_adc_read_MSB()) << 8;
 208   1          ad_value = ad_value | hal_adc_read_LSB();
 209   1          temp = ad_value * 1.2 * 3 * 100 / 4096; //µçÑ¹À©´ó100±¶
 210   1          TagInfo.CellVoltageH = temp / 100; //
 211   1          TagInfo.CellVoltageL = ((temp % 100 / 10) << 4) | (temp % 100 % 10);
 212   1      }
 213          
 214          void AHT10(void) {
 215   1          uint8_t temp[5];
 216   1          uint8_t humidity[5];
 217   1      
 218   1          memset(temp, 0, 5);
 219   1          memset(humidity, 0, 5);
 220   1          temp[2] = '.';
 221   1          humidity[2] = '.';
 222   1      
 223   1          //while(1)
 224   1          {
 225   2      
 226   2              //DisableIrq(); //ÓÉÓÚÊÇÄ£ÄâI2C,Îª¶ÁÈ¡Êý¾Ý¸ü×¼È· £¬¶ÁÈ¡Ö®Ç°½ûÖ¹ÖÐ¶Ï
 227   2              Read_AHT10();  //¶ÁÈ¡ÎÂ¶ÈºÍÊª¶È £¬ ¿É¼ä¸ô1.5S¶ÁÒ»´Î
 228   2              //EnableIrq(); //»Ö¸´ÖÐ¶Ï
 229   2      
 230   2              TagInfo.tempH = AHT10Value.tempH ;
 231   2              TagInfo.tempL = AHT10Value.tempL ;
 232   2              TagInfo.humyH = AHT10Value.humyH ;
 233   2              TagInfo.humyL = AHT10Value.humyL ;
 234   2      
 235   2              temp[0] = (AHT10Value.tempH >> 4) + 0x30;
 236   2              temp[1] = (AHT10Value.tempH & 0x0f) + 0x30;
 237   2              temp[3] = (AHT10Value.tempL >> 4) + 0x30;
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 5   

 238   2              humidity[0] = (TagInfo.humyH >> 4) + 0x30;
 239   2              humidity[1] = (TagInfo.humyH & 0x0f) + 0x30;
 240   2              humidity[3] = (TagInfo.humyL >> 4) + 0x30;
 241   2      
 242   2              PutString("AHT10-ÎÂ¶È:");
 243   2              PutString(temp);
 244   2              PutString("    ");
 245   2              PutString("Êª¶È:");
 246   2              PutString(humidity);
 247   2              PutString("\r\n");
 248   2              /**/
 249   2              //delay_ms(1500); //ÑÓÊ±1.5S
 250   2              //Îª¶ÁÈ¡µÄÊý¾Ý¸üÎÈ¶¨£¬»¹¿ÉÒÔÊ¹ÓÃÆ½¾ùÖµÂË²¨»òÕß´°¿ÚÂË²¨£¬»òÕßÇ°Ãæ¶ÁÈ¡µÄÖµÓëºóÃæµÄÖµÏà²î²»ÄÜÌ«´ó¡£
 251   2          }
 252   1      }
 253          void  Send_data() {
 254   1          Assemble_Data();  // Êý¾Ý´ò°ü
 255   1          hal_nrf_write_tx_payload(TxPayload, MAX_TX_PAYLOAD);
 256   1      
 257   1          CE_PULSE();             //ÎÞÏß·¢ÉäÊý¾Ý
 258   1          radio_busy = true;
 259   1          while(radio_busy)       //µÈ´ý²Ù×÷Íê³É
 260   1              ;
 261   1      #if (BOARD == IKMSIK)
                  led_flash(led1);
              #else   
 264   1          led_flash(led3);
 265   1      #endif
 266   1      }
 267          /*******************************************************************************************************
 268           * Ãè  Êö : »ñÈ¡ÉÏÒ»´ÎµÍ¹¦ºÄÄ£Ê½£¬²¢Í¨¹ý´®¿Ú´òÓ¡
 269           * Èë  ²Î : ÎÞ
 270           * ·µ»ØÖµ : ÎÞ
 271           *******************************************************************************************************/
 272          void GetPrintLastPWM(void) {
 273   1          uint8_t PowrMode;
 274   1      
 275   1          PowrMode = PWRDWN & 0x07;
 276   1      
 277   1          switch(PowrMode) {
 278   2          case 0x00:
 279   2              PutString("Last mode:Power Off!");
 280   2              break;
 281   2          case 0x01:
 282   2              PutString("Last mode:Deep Sleep!");
 283   2              break;
 284   2          case 0x02:
 285   2              PutString("Last mode:Memory Retention, Timer Off!");
 286   2              break;
 287   2          case 0x03:
 288   2              PutString("Last mode:Memory Retention, Timer On!");
 289   2              break;
 290   2          case 0x04:
 291   2              PutString("Last mode:Register Retention!");
 292   2              break;
 293   2          default  :
 294   2              PutString("Error Or Reserved!");
 295   2              break;
 296   2          }
 297   1      }
 298          /*******************************************************************************************************
 299           * Ãè  Êö : ÉèÖÃ»½ÐÑPIN
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 6   

 300           * Èë  ²Î : ÎÞ
 301           * ·µ»ØÖµ : ÎÞ
 302           *******************************************************************************************************/
 303          void SetWakeUpPin(void) {
 304   1          OPMCON = 0x04;             /* ¿ªËø£¬µÍµçÆ½»½ÐÑ          */
 305   1          WUOPC0 = 0x00;             /* P0»½ÐÑµÄÒý½ÅÉèÖÃ£ºÎÞ      */
 306   1          WUOPC1 = 0x04;             /* P1»½ÐÑµÄÒý½ÅÉèÖÃ£ºP12     */
 307   1      
 308   1          P1DIR |= 0x04;             /* P12³õÊ¼»¯ÎªÊäÈëI/O¿Ú      */
 309   1          P12   = 1;                 /* P12³õÊ¼»¯Îª¸ßµçÆ½         */
 310   1      }
 311          /*******************************************************************************************************
 312           * Ãè  Êö : Ö÷º¯Êý
 313           * Èë  ²Î : ÎÞ
 314           * ·µ»ØÖµ : ÎÞ
 315           *******************************************************************************************************/
 316          
 317          
 318          #define  DEEPSLEEP        1  // Éî¶ÈË¯Ãß
 319          #define  MEMRET_TIMEOFF   2  // ´æ´¢Æ÷Î¬³Ö£¬¶¨Ê±Æ÷¹Ø±Õ
 320          #define  MEMRET_TIMEON    3  // ´æ´¢Æ÷Î¬³Ö£¬¶¨Ê±Æ÷¿ªÆô
 321          #define  REGRET           4  // ¼Ä´æÆ÷Î¬³Ö
 322          /*******************************************************************************************************
 323           * Ãè  Êö : ÉèÖÃnRF24LE1µÍ¹¦ºÄÄ£Ê½
 324           * Èë  ²Î : mode:µÍ¹¦ºÄÄ£Ê½
 325           * ·µ»ØÖµ : ÎÞ
 326           *******************************************************************************************************/
 327          void SetPowrDownMode(uint8_t mode) {
 328   1          uint8_t PowrMode;
 329   1      
 330   1          switch(mode) {
 331   2          case DEEPSLEEP  :     // Éî¶ÈË¯Ãß£¬»½ÐÑºó¸´Î»
 332   2              PowrMode = 0x01;
 333   2              break;
 334   2          case MEMRET_TIMEOFF : // ´æ´¢Æ÷Î¬³Ö£¬¶¨Ê±Æ÷¹Ø±Õ£¬»½ÐÑºó¸´Î»
 335   2              PowrMode = 0x02;
 336   2              break;
 337   2          case MEMRET_TIMEON:   // ´æ´¢Æ÷Î¬³Ö£¬¶¨Ê±Æ÷¿ªÆô£¬»½ÐÑºó¸´Î»
 338   2              PowrMode = 0x03;
 339   2              break;
 340   2          case REGRET :         // ¼Ä´æÆ÷Î¬³Ö
 341   2              PowrMode = 0x04;
 342   2              break;
 343   2          default         :    //ÔËÐÐ
 344   2              PowrMode = 0x00;
 345   2              break;
 346   2          }
 347   1      
 348   1          if(PowrMode == 0x01)hal_clk_set_16m_source(HAL_CLK_RCOSC16M); // ½øÈëµ½DEEPSLEEPÇ°Ò»¶¨ÒªÆôÓÃRCÊ±ÖÓÔ´
 349   1          if((PowrMode == 0x01) || (PowrMode == 0x02) || (PowrMode == 0x03))OPMCON |= 0x02;  // Õâ3ÖÖµÍ¹¦ºÄÄ£Ê½»
             -½ÐÑºónRF24LE1»á¸´Î»£¬ËùÒÔÒªËø¶¨IO
 350   1      
 351   1          PWRDWN = PowrMode;
 352   1          PWRDWN = 0x00;  // Clear power down
 353   1      }
 354          
 355          void main(void) {
 356   1          uint8_t RfReceLen,i, second = 0;
 357   1          uint32_t  minute = 0;
 358   1      
 359   1          TagInfo.id.id16 = TAG_ID;
 360   1      #ifdef DEBUG_UART
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 7   

                  hal_uart_init(UART_BAUD_57K6); // ³õÊ¼»¯UART0
                  while(hal_clk_get_16m_source() != HAL_CLK_XOSC16M) //µÈ´ýÊ±ÖÓÎÈ¶¨
                      ;
              #endif
 365   1          IoInit();      //ÅäÖÃIO
 366   1          SetWakeUpPin(); //ÉèÖÃ»½ÐÑ¹Ü½Å
 367   1          led_init();
 368   1          key_init();
 369   1          mcu_init();
 370   1          adc_init();    
 371   1          RfCofig();
 372   1          if(AHT10_Init() == 0)PutString("AHT10_Init fial !!!\r\n");
 373   1      #if USE_WDT
*** WARNING C322 IN LINE 373 OF main.c: unknown identifier
                  hal_wdog_init(WDT_TIME);//ÅäÖÃ¿´ÃÅ¹·³¬Ê±Ê±¼ä2s£¬Ê¹ÄÜ¿´ÃÅ¹·
              #endif
 376   1          PutString("Program starting...\r\n");
 377   1          for(i = 0;i < 3; i ++){
 378   2            led_on(led2);
 379   2            delay_ms(100);
 380   2            led_off(led2);
 381   2            delay_ms(100);
 382   2          }
 383   1          GetPrintLastPWM();
 384   1          CellVoltage();
 385   1          AHT10();
 386   1          Send_data();    
 387   1          
 388   1          while(1) {
 389   2      #if USE_WDT
*** WARNING C322 IN LINE 389 OF main.c: unknown identifier
                      hal_wdog_restart(); //Î¹¹·
              #endif
 392   2              if(KEY1 == 0) {
 393   3                  delay_ms(100);
 394   3                  if(KEY1 == 0) {
 395   4                      second = 0;
 396   4                      minute = 0;
 397   4                      CellVoltage();
 398   4                      AHT10();
 399   4                      Send_data();
 400   4                  }
 401   3              }
 402   2              if(second <= MINUTE) { //Ò»·ÖÖÓ
 403   3                  second++;
 404   3                  SetPowrDownMode(REGRET);
 405   3                  PutString("into REGRET\n");
 406   3              } else {
 407   3                  second = 0;
 408   3                  minute++;
 409   3                  if(minute == 24 * HOUR) {
 410   4                      PutString("into DEEPSLEEP\n");
 411   4                      //SetPowrDownMode(DEEPSLEEP);             
 412   4                      CellVoltage();
 413   4                      minute = 0;
 414   4                  }
 415   3                  AHT10();
 416   3                  Send_data();
 417   3              }
 418   2          }
 419   1      }
*** WARNING C280 IN LINE 356 OF main.c: 'RfReceLen': unreferenced local variable
C51 COMPILER V9.54   MAIN                                                                  08/15/2019 15:51:52 PAGE 8   

 420          /*******************************************************************************************************
 421           * Ãè  Êö : ÎÞÏßÖÐ¶Ï·þÎñº¯Êý
 422           * Èë  ²Î : ÎÞ
 423           * ·µ»ØÖµ : ÎÞ
 424           *******************************************************************************************************/
 425          void rf_irq() interrupt INTERRUPT_RFIRQ {
 426   1          uint8_t  irq_flags;
 427   1      
 428   1          irq_flags = hal_nrf_get_clear_irq_flags(); //¶ÁÈ¡²¢Çå³ýÎÞÏßÖÐ¶Ï±êÖ¾
 429   1      
 430   1          if(irq_flags & (1 << HAL_NRF_RX_DR)) { //½ÓÊÕµ½Êý¾Ý?
 431   2      
 432   2              while(!hal_nrf_rx_fifo_empty()) { // Read payload
 433   3                  PipeAndLen = hal_nrf_read_rx_payload(RxPayload);//¶ÁÈ¡Êý¾Ý
 434   3              }
 435   2              radio_busy = false;
 436   2          }
 437   1      
 438   1          if(irq_flags & ((1 << HAL_NRF_TX_DS))) {    // transimmter finish
 439   2              radio_busy = false;
 440   2          }
 441   1      
 442   1          if(irq_flags & ((1 << HAL_NRF_MAX_RT))) {   // re-transimmter
 443   2              radio_busy = false;
 444   2              hal_nrf_flush_tx();
 445   2          }
 446   1      }
 447          /********************************************END FILE*****************************************************
             -/
 448          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1493    ----
   CONSTANT SIZE    =    268    ----
   XDATA SIZE       =     73       2
   PDATA SIZE       =      7      33
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
